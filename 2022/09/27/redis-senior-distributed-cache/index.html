<!DOCTYPE HTML>
<html lang="en">


<head>
    <meta charset="utf-8">
    <meta name="keywords" content="redis-senior-distributed-cache, cflxl">
    <meta name="description" content="分布式缓存– 基于Redis集群解决单机Redis存在的问题
单机的Redis存在四大问题：


数据丢失问题：Redis是内存存储，服务重启可能会丢失数据。
并发能力问题：单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="referrer" content="no-referrer-when-downgrade">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>redis-senior-distributed-cache | cflxl</title>
    <link rel="icon" type="image/jpeg" href="https://github.com/cflxl/pictures/raw/master/pictures/cfl.jpg">
    


    <!-- bg-cover style     -->



<link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.min.css">
<link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
<link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
<link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
<link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
<link rel="stylesheet" type="text/css" href="/css/matery.css">
<link rel="stylesheet" type="text/css" href="/css/my.css">
<link rel="stylesheet" type="text/css" href="/css/dark.css" media="none" onload="if(media!='all')media='all'">




    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
    <link rel="stylesheet" href="/css/post.css">




    
        <link rel="stylesheet" type="text/css" href="/css/reward.css">
    



    <script src="/libs/jquery/jquery-3.6.0.min.js"></script>

<meta name="generator" content="Hexo 6.3.0"><link rel="alternate" href="/atom.xml" title="cflxl" type="application/atom+xml">
<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head>


<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="https://github.com/cflxl/pictures/raw/master/pictures/cfl.jpg" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">cflxl</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>Index</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>Tags</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>Archives</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>About</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="Search" style="zoom: 0.85;"></i>
    </a>
  </li>
  <li>
    <a href="javascript:;" class="waves-effect waves-light" onclick="switchNightMode()" title="深色/浅色模式" >
      <i id="sum-moon-icon" class="fas fa-sun" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="https://github.com/cflxl/pictures/raw/master/pictures/cfl.jpg" class="logo-img circle responsive-img">
        
        <div class="logo-name">cflxl</div>
        <div class="logo-desc">
            
            Never really desperate, only the lost of the soul.
            
        </div>
    </div>

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			Index
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			Tags
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			Archives
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			About
		</a>
          
        </li>
        
        
    </ul>
</div>


        </div>

        
    </nav>

</header>

    



<div class="bg-cover pd-header post-cover" style="background-image: url('https://github.com/cflxl/pictures/raw/master/pictures/10.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">redis-senior-distributed-cache</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/redis/">
                                <span class="chip bg-color">redis</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>Publish Date:&nbsp;&nbsp;
                    2022-09-27
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>Update Date:&nbsp;&nbsp;
                    2022-11-17
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>Word Count:&nbsp;&nbsp;
                    5k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>Read Times:&nbsp;&nbsp;
                    18 Min
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>Read Count:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">

        

        

        <div class="card-content article-card-content">
            <div id="articleContent">
                <h1 id="分布式缓存"><a href="#分布式缓存" class="headerlink" title="分布式缓存"></a>分布式缓存</h1><p>– 基于Redis集群解决单机Redis存在的问题</p>
<p>单机的Redis存在四大问题：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221020201549352.png" alt="image-20221020201549352"></p>
<ul>
<li>数据丢失问题：Redis是内存存储，服务重启可能会丢失数据。</li>
<li>并发能力问题：单节点Redis并发能力虽然不错，但也无法满足如618这样的高并发场景。</li>
<li>故障恢复问题：如果Redis宕机，则服务不可用，需要一种自动的故障恢复手段。</li>
<li>存储能力问题：Redis基于内存，单节点能存储的数据量难以满足海量数据需求。</li>
</ul>
<h2 id="1-Redis持久化"><a href="#1-Redis持久化" class="headerlink" title="1. Redis持久化"></a>1. Redis持久化</h2><p>Redis有两种持久化方案：</p>
<ul>
<li>RDB持久化</li>
<li>AOF持久化</li>
</ul>
<h3 id="1-1-RDB持久化"><a href="#1-1-RDB持久化" class="headerlink" title="1.1. RDB持久化"></a>1.1. RDB持久化</h3><p>RDB全称Redis Database Backup file（Redis数据备份文件），也被叫做Redis数据快照。简单来说就是把内存中的所有数据都记录到磁盘中。当Redis实例故障重启后，从磁盘读取快照文件，恢复数据。快照文件称为RDB文件，默认是保存在当前运行目录。</p>
<h4 id="1-1-1-执行时机"><a href="#1-1-1-执行时机" class="headerlink" title="1.1.1. 执行时机"></a>1.1.1. 执行时机</h4><p>RDB持久化在四种情况下会执行：</p>
<ul>
<li>执行save命令</li>
<li>执行bgsave命令</li>
<li>Redis停机时</li>
<li>触发RDB条件时</li>
</ul>
<p><strong>1）save命令</strong></p>
<p>执行下面的命令，可以立即执行一次RDB：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221020204850644.png" alt="image-20221020204850644"></p>
<p>save命令会导致主进程执行RDB，这个过程中其它所有命令都会被阻塞。只有在数据迁移时可能用到。</p>
<p><strong>2）bgsave命令</strong></p>
<p>下面的命令可以异步执行RDB：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221020204902729.png" alt="image-20221020204902729"></p>
<p>这个命令执行后会开启独立进程完成RDB，主进程可以持续处理用户请求，不受影响。</p>
<p><strong>3）停机时</strong></p>
<p>Redis停机时会执行一次save命令，实现RDB持久化。</p>
<p><strong>4）触发RDB条件</strong></p>
<p>Redis内部有触发RDB的机制，可以在redis.conf文件中找到，格式如下：</p>
<pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 900秒内，如果至少有1个key被修改，则执行bgsave ， 如果是save "" 则表示禁用RDB</span>
<span class="token attr-name">save</span> <span class="token attr-value">900 1  </span>
<span class="token attr-name">save</span> <span class="token attr-value">300 10  </span>
<span class="token attr-name">save</span> <span class="token attr-value">60 10000 </span>
</code></pre>
<p>RDB的其它配置也可以在redis.conf文件中设置：</p>
<pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 是否压缩 ,建议不开启，压缩也会消耗cpu，磁盘的话不值钱</span>
<span class="token attr-name">rdbcompression</span> <span class="token attr-value">yes</span>

<span class="token comment" spellcheck="true"># RDB文件名称</span>
<span class="token attr-name">dbfilename</span> <span class="token attr-value">dump.rdb  </span>

<span class="token comment" spellcheck="true"># 文件保存的路径目录</span>
<span class="token attr-name">dir</span> <span class="token attr-value">./ </span>
</code></pre>
<h4 id="1-1-2-RDB原理"><a href="#1-1-2-RDB原理" class="headerlink" title="1.1.2. RDB原理"></a>1.1.2. RDB原理</h4><p>bgsave开始时会fork主进程得到子进程，子进程共享主进程的内存数据。完成fork后读取内存数据并写入 RDB 文件。</p>
<p>fork采用的是copy-on-write技术：</p>
<ul>
<li>当主进程执行读操作时，访问共享内存；</li>
<li>当主进程执行写操作时，则会拷贝一份数据，执行写操作。</li>
</ul>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022135222353.png" alt="image-20221022135222353"></p>
<h4 id="1-1-3-小结"><a href="#1-1-3-小结" class="headerlink" title="1.1.3. 小结"></a>1.1.3. 小结</h4><p>RDB方式bgsave的基本流程？</p>
<ul>
<li>fork主进程得到一个子进程，共享内存空间</li>
<li>子进程读取内存数据并写入新的RDB文件</li>
<li>用新RDB文件替换旧的RDB文件</li>
</ul>
<p>RDB会在什么时候执行？save 60 1000代表什么含义？</p>
<ul>
<li>默认是服务停止时</li>
<li>代表60秒内至少执行1000次修改则触发RDB</li>
</ul>
<p>RDB的缺点？</p>
<ul>
<li>RDB执行间隔时间长，两次RDB之间写入数据有丢失的风险</li>
<li>fork子进程、压缩、写出RDB文件都比较耗时</li>
</ul>
<h3 id="1-2-AOF持久化"><a href="#1-2-AOF持久化" class="headerlink" title="1.2. AOF持久化"></a>1.2. AOF持久化</h3><h4 id="1-2-1-AOF原理"><a href="#1-2-1-AOF原理" class="headerlink" title="1.2.1. AOF原理"></a>1.2.1. AOF原理</h4><p>AOF全称为Append Only File（追加文件）。Redis处理的每一个写命令都会记录在AOF文件，可以看做是命令日志文件。</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022140405274.png" alt="image-20221022140405274"></p>
<h4 id="1-2-2-AOF配置"><a href="#1-2-2-AOF配置" class="headerlink" title="1.2.2. AOF配置"></a>1.2.2. AOF配置</h4><p>AOF默认是关闭的，需要修改redis.conf配置文件来开启AOF：</p>
<pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 是否开启AOF功能，默认是no</span>
<span class="token attr-name">appendonly</span> <span class="token attr-value">yes</span>
<span class="token comment" spellcheck="true"># AOF文件的名称</span>
<span class="token attr-name">appendfilename</span> <span class="token attr-value">"appendonly.aof"</span>
</code></pre>
<p>AOF的命令记录的频率也可以通过redis.conf文件来配：</p>
<pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 表示每执行一次写命令，立即记录到AOF文件</span>
<span class="token attr-name">appendfsync</span> <span class="token attr-value">always </span>
<span class="token comment" spellcheck="true"># 写命令执行完先放入AOF缓冲区，然后表示每隔1秒将缓冲区数据写到AOF文件，是默认方案</span>
<span class="token attr-name">appendfsync</span> <span class="token attr-value">everysec </span>
<span class="token comment" spellcheck="true"># 写命令执行完先放入AOF缓冲区，由操作系统决定何时将缓冲区内容写回磁盘</span>
<span class="token attr-name">appendfsync</span> <span class="token attr-value">no</span>
</code></pre>
<p>三种策略对比：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022140832570.png" alt="image-20221022140832570"></p>
<h4 id="1-2-3-AOF文件重写"><a href="#1-2-3-AOF文件重写" class="headerlink" title="1.2.3. AOF文件重写"></a>1.2.3. AOF文件重写</h4><p>因为是记录命令，AOF文件会比RDB文件大的多。而且AOF会记录对同一个key的多次写操作，但只有最后一次写操作才有意义。通过执行bgrewriteaof命令，可以让AOF文件执行重写功能，用最少的命令达到相同效果。</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022141604713.png" alt="image-20221022141604713"></p>
<p>如图，AOF原本有三个命令，但是<code>set num 123 和 set num 666</code>都是对num的操作，第二次会覆盖第一次的值，因此第一个命令记录下来没有意义。</p>
<p>所以重写命令后，AOF文件内容就是：<code>mset name jack num 666</code></p>
<p>Redis也会在触发阈值时自动去重写AOF文件。阈值也可以在redis.conf中配置：</p>
<pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># AOF文件比上次文件 增长超过多少百分比则触发重写</span>
<span class="token attr-name">auto-aof-rewrite-percentage</span> <span class="token attr-value">100</span>
<span class="token comment" spellcheck="true"># AOF文件体积最小多大以上才触发重写 </span>
<span class="token attr-name">auto-aof-rewrite-min-size</span> <span class="token attr-value">64mb </span>
</code></pre>
<h3 id="1-3-RDB与AOF对比"><a href="#1-3-RDB与AOF对比" class="headerlink" title="1.3. RDB与AOF对比"></a>1.3. RDB与AOF对比</h3><p>RDB和AOF各有自己的优缺点，如果对数据安全性要求较高，在实际开发中往往会<strong>结合</strong>两者来使用。</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022141959441.png" alt="image-20221022141959441"></p>
<h2 id="2-Redis主从"><a href="#2-Redis主从" class="headerlink" title="2. Redis主从"></a>2. Redis主从</h2><h3 id="2-1-搭建主从架构"><a href="#2-1-搭建主从架构" class="headerlink" title="2.1. 搭建主从架构"></a>2.1. 搭建主从架构</h3><p>单节点Redis的并发能力是有上限的，要进一步提高Redis的并发能力，就需要搭建主从集群，实现读写分离。</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022142523647.png" alt="image-20221022142523647"></p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022143314568.png" alt="image-20221022143314568"></p>
<h3 id="2-2-主从数据同步原理"><a href="#2-2-主从数据同步原理" class="headerlink" title="2.2. 主从数据同步原理"></a>2.2. 主从数据同步原理</h3><h4 id="2-2-1-全量同步"><a href="#2-2-1-全量同步" class="headerlink" title="2.2.1. 全量同步"></a>2.2.1. 全量同步</h4><p>主从第一次建立连接时，会执行<strong>全量同步</strong>，将master节点的所有数据都拷贝给slave节点，流程：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022143417787.png" alt="image-20221022143417787"></p>
<p>这里有一个问题，master如何得知salve是第一次来连接呢？？</p>
<p>有几个概念，可以作为判断依据：</p>
<ul>
<li><strong>Replication Id</strong>：简称replid，是数据集的标记，id一致则说明是同一数据集。每一个master都有唯一的replid，slave则会继承master节点的replid</li>
<li><strong>offset</strong>：偏移量，随着记录在repl_baklog中的数据增多而逐渐增大。slave完成同步时也会记录当前同步的offset。如果slave的offset小于master的offset，说明slave数据落后于master，需要更新。</li>
</ul>
<p>因此slave做数据同步，必须向master声明自己的replication id 和offset，master才可以判断到底需要同步哪些数据。</p>
<p>因为slave原本也是一个master，有自己的replid和offset，当第一次变成slave，与master建立连接时，发送的replid和offset是自己的replid和offset。</p>
<p>master判断发现slave发送来的replid与自己的不一致，说明这是一个全新的slave，就知道要做全量同步了。</p>
<p>master会将自己的replid和offset都发送给这个slave，slave保存这些信息。以后slave的replid就与master一致了。</p>
<p>因此，<strong>master判断一个节点是否是第一次同步的依据，就是看replid是否一致</strong>。</p>
<p>如图：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022150805971.png" alt="image-20221022150805971"></p>
<p>完整流程描述：</p>
<ul>
<li>slave节点请求增量同步</li>
<li>master节点判断replid，发现不一致，拒绝增量同步</li>
<li>master将完整内存数据生成RDB，发送RDB到slave</li>
<li>slave清空本地数据，加载master的RDB</li>
<li>master将RDB期间的命令记录在repl_baklog，并持续将log中的命令发送给slave</li>
<li>slave执行接收到的命令，保持与master之间的同步</li>
</ul>
<h4 id="2-2-2-增量同步"><a href="#2-2-2-增量同步" class="headerlink" title="2.2.2. 增量同步"></a>2.2.2. 增量同步</h4><p>全量同步需要先做RDB，然后将RDB文件通过网络传输个slave，成本太高了。因此除了第一次做全量同步，其它大多数时候slave与master都是做<strong>增量同步</strong>。</p>
<p>什么是增量同步？就是只更新slave与master存在差异的部分数据。如图：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022185720880.png" alt="image-20221022185720880"></p>
<h4 id="2-2-3-repl-backlog原理"><a href="#2-2-3-repl-backlog原理" class="headerlink" title="2.2.3. repl_backlog原理"></a>2.2.3. repl_backlog原理</h4><p>master怎么知道slave与自己的数据差异在哪里呢?</p>
<p>这就要说到全量同步时的repl_baklog文件了。</p>
<p>这个文件是一个固定大小的数组，只不过数组是环形，也就是说<strong>角标到达数组末尾后，会再次从0开始读写</strong>，这样数组头部的数据就会被覆盖。</p>
<p>repl_baklog中会记录Redis处理过的命令日志及offset，包括master当前的offset，和slave已经拷贝到的offset：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022190259587.png" alt="image-20221022190259587"></p>
<p>slave与master的offset之间的差异，就是salve需要增量拷贝的数据了。</p>
<p>随着不断有数据写入，master的offset逐渐变大，slave也不断的拷贝，追赶master的offset：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022191146955.png" alt="image-20221022191146955"></p>
<p>直到数组被填满：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022191159334.png" alt="image-20221022191159334"></p>
<p>此时，如果有新的数据写入，就会覆盖数组中的旧数据。不过，旧的数据只要是绿色的，说明是已经被同步到slave的数据，即便被覆盖了也没什么影响。因为未同步的仅仅是红色部分。</p>
<p>但是，如果slave出现网络阻塞，导致master的offset远远超过了slave的offset： </p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022191212364.png" alt="image-20221022191212364"></p>
<p>如果master继续写入新数据，其offset就会覆盖旧的数据，直到将slave现在的offset也覆盖：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022191227505.png" alt="image-20221022191227505"></p>
<p>棕色框中的红色部分，就是尚未同步，但是却已经被覆盖的数据。此时如果slave恢复，需要同步，却发现自己的offset都没有了，无法完成增量同步了。只能做全量同步。</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022191240026.png" alt="image-20221022191240026"></p>
<h3 id="2-3-主从同步优化"><a href="#2-3-主从同步优化" class="headerlink" title="2.3. 主从同步优化"></a>2.3. 主从同步优化</h3><p>主从同步可以保证主从数据的一致性，非常重要。</p>
<p>可以从以下几个方面来优化Redis主从集群：</p>
<ul>
<li>在master中配置repl-diskless-sync yes启用无磁盘复制，避免全量同步时的磁盘IO。</li>
<li>Redis单节点上的内存占用不要太大，减少RDB导致的过多磁盘IO</li>
<li>适当提高repl_baklog的大小，发现slave宕机时尽快实现故障恢复，尽可能避免全量同步</li>
<li>限制一个master上的slave节点数量，如果实在是太多slave，则可以采用主-从-从链式结构，减少master压力</li>
</ul>
<p>主从从架构图：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022192605675.png" alt="image-20221022192605675"></p>
<h3 id="2-4-小结"><a href="#2-4-小结" class="headerlink" title="2.4. 小结"></a>2.4. 小结</h3><p>简述全量同步和增量同步区别？</p>
<ul>
<li>全量同步：master将完整内存数据生成RDB，发送RDB到slave。后续命令则记录在repl_baklog，逐个发送给slave。</li>
<li>增量同步：slave提交自己的offset到master，master获取repl_baklog中从offset之后的命令给slave</li>
</ul>
<p>什么时候执行全量同步？</p>
<ul>
<li>slave节点第一次连接master节点时</li>
<li>slave节点断开时间太久，repl_baklog中的offset已经被覆盖时</li>
</ul>
<p>什么时候执行增量同步？</p>
<ul>
<li>slave节点断开又恢复，并且在repl_baklog中能找到offset时</li>
</ul>
<h2 id="3-Redis哨兵"><a href="#3-Redis哨兵" class="headerlink" title="3. Redis哨兵"></a>3. Redis哨兵</h2><p>Redis提供了哨兵（Sentinel）机制来实现主从集群的自动故障恢复。</p>
<h3 id="3-1-哨兵原理"><a href="#3-1-哨兵原理" class="headerlink" title="3.1. 哨兵原理"></a>3.1. 哨兵原理</h3><h4 id="3-1-1-集群结构和作用"><a href="#3-1-1-集群结构和作用" class="headerlink" title="3.1.1. 集群结构和作用"></a>3.1.1. 集群结构和作用</h4><p>哨兵的结构如图：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022193626368.png" alt="image-20221022193626368"></p>
<p>哨兵的作用如下：</p>
<ul>
<li><strong>监控</strong>：Sentinel 会不断检查您的master和slave是否按预期工作</li>
<li><strong>自动故障恢复</strong>：如果master故障，Sentinel会将一个slave提升为master。当故障实例恢复后也以新的master为主</li>
<li><strong>通知</strong>：Sentinel充当Redis客户端的服务发现来源，当集群发生故障转移时，会将最新信息推送给Redis的客户端</li>
</ul>
<h4 id="3-1-2-集群监控原理"><a href="#3-1-2-集群监控原理" class="headerlink" title="3.1.2. 集群监控原理"></a>3.1.2. 集群监控原理</h4><p>Sentinel基于心跳机制监测服务状态，每隔1秒向集群的每个实例发送ping命令：</p>
<ul>
<li><p>主观下线：如果某sentinel节点发现某实例未在规定时间响应，则认为该实例<strong>主观下线</strong>。</p>
</li>
<li><p>客观下线：若超过指定数量（quorum）的sentinel都认为该实例主观下线，则该实例<strong>客观下线</strong>。quorum值最好超过Sentinel实例数量的一半。</p>
</li>
</ul>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022194122741.png" alt="image-20221022194122741"></p>
<h4 id="3-1-3-集群故障恢复原理"><a href="#3-1-3-集群故障恢复原理" class="headerlink" title="3.1.3. 集群故障恢复原理"></a>3.1.3. 集群故障恢复原理</h4><p>一旦发现master故障，sentinel需要在salve中选择一个作为新的master，选择依据是这样的：</p>
<ul>
<li>首先会判断slave节点与master节点断开时间长短，如果超过指定值（down-after-milliseconds * 10）则会排除该slave节点</li>
<li>然后判断slave节点的slave-priority值，越小优先级越高，如果是0则永不参与选举</li>
<li>如果slave-prority一样，则判断slave节点的offset值，越大说明数据越新，优先级越高</li>
<li>最后是判断slave节点的运行id大小，越小优先级越高。</li>
</ul>
<p>当选出一个新的master后，该如何实现切换呢？</p>
<p>流程如下：</p>
<ul>
<li>sentinel给备选的slave1节点发送slaveof no one命令，让该节点成为master</li>
<li>sentinel给所有其它slave发送slaveof 192.168.150.101 7002 命令，让这些slave成为新master的从节点，开始从新的master上同步数据。</li>
<li>最后，sentinel将故障节点标记为slave，当故障节点恢复后会自动成为新的master的slave节点</li>
</ul>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221022194731826.png" alt="image-20221022194731826"></p>
<h4 id="3-1-4-小结"><a href="#3-1-4-小结" class="headerlink" title="3.1.4. 小结"></a>3.1.4. 小结</h4><p>Sentinel的三个作用是什么？</p>
<ul>
<li>监控</li>
<li>故障转移</li>
<li>通知</li>
</ul>
<p>Sentinel如何判断一个redis实例是否健康？</p>
<ul>
<li>每隔1秒发送一次ping命令，如果超过一定时间没有相向则认为是主观下线</li>
<li>如果大多数sentinel都认为实例主观下线，则判定服务下线</li>
</ul>
<p>故障转移步骤有哪些？</p>
<ul>
<li>首先选定一个slave作为新的master，执行slaveof no one</li>
<li>然后让所有节点都执行slaveof 新master</li>
<li>修改故障节点配置，添加slaveof 新master</li>
</ul>
<h3 id="3-2-搭建哨兵集群"><a href="#3-2-搭建哨兵集群" class="headerlink" title="3.2. 搭建哨兵集群"></a>3.2. 搭建哨兵集群</h3><p>见其他文件</p>
<h3 id="3-3-RedisTemplate"><a href="#3-3-RedisTemplate" class="headerlink" title="3.3. RedisTemplate"></a>3.3. RedisTemplate</h3><p>在Sentinel集群监管下的Redis主从集群，其节点会因为自动故障转移而发生变化，Redis的客户端必须感知这种变化，及时更新连接信息。Spring的RedisTemplate底层利用lettuce实现了节点的感知和自动切换。</p>
<p>下面，我们通过一个测试来实现RedisTemplate集成哨兵机制。</p>
<h4 id="3-3-1-导入项目"><a href="#3-3-1-导入项目" class="headerlink" title="3.3.1. 导入项目"></a>3.3.1. 导入项目</h4><p>我新建一个模块导入这个项目</p>
<h4 id="3-3-2-引入依赖"><a href="#3-3-2-引入依赖" class="headerlink" title="3.3.2. 引入依赖"></a>3.3.2. 引入依赖</h4><p>在项目的pom文件中引入依赖：</p>
<pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-data-redis<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>
</code></pre>
<h4 id="3-3-3-配置Redis地址"><a href="#3-3-3-配置Redis地址" class="headerlink" title="3.3.3. 配置Redis地址"></a>3.3.3. 配置Redis地址</h4><p>然后在配置文件application.yml中指定redis的sentinel相关信息：</p>
<pre class=" language-java"><code class="language-java">spring<span class="token operator">:</span>
  redis<span class="token operator">:</span>
    sentinel<span class="token operator">:</span>
      master<span class="token operator">:</span> mymaster
      nodes<span class="token operator">:</span>
        <span class="token operator">-</span> <span class="token number">112.74</span><span class="token punctuation">.</span><span class="token number">33.85</span><span class="token operator">:</span><span class="token number">27001</span>
        <span class="token operator">-</span> <span class="token number">112.74</span><span class="token punctuation">.</span><span class="token number">33.85</span><span class="token operator">:</span><span class="token number">27002</span>
        <span class="token operator">-</span> <span class="token number">112.74</span><span class="token punctuation">.</span><span class="token number">33.85</span><span class="token operator">:</span><span class="token number">27003</span>
</code></pre>
<h4 id="3-3-4-配置读写分离"><a href="#3-3-4-配置读写分离" class="headerlink" title="3.3.4. 配置读写分离"></a>3.3.4. 配置读写分离</h4><p>在项目的启动类中，添加一个新的bean：</p>
<pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Bean</span>
<span class="token keyword">public</span> LettuceClientConfigurationBuilderCustomizer <span class="token function">clientConfigurationBuilderCustomizer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>#<span class="token number">123</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> clientConfigurationBuilder <span class="token operator">-</span><span class="token operator">></span> clientConfigurationBuilder<span class="token punctuation">.</span><span class="token function">readFrom</span><span class="token punctuation">(</span>ReadFrom<span class="token punctuation">.</span>REPLICA_PREFERRED<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">&amp;</span>#<span class="token number">125</span><span class="token punctuation">;</span>
</code></pre>
<p>这个bean中配置的就是读写策略，包括四种：</p>
<ul>
<li>MASTER：从主节点读取</li>
<li>MASTER_PREFERRED：优先从master节点读取，master不可用才读取replica</li>
<li>REPLICA：从slave（replica）节点读取</li>
<li>REPLICA _PREFERRED：优先从slave（replica）节点读取，所有的slave都不可用才读取master</li>
</ul>
<h2 id="4-Redis分片集群"><a href="#4-Redis分片集群" class="headerlink" title="4. Redis分片集群"></a>4. Redis分片集群</h2><h3 id="4-1-搭建分片集群"><a href="#4-1-搭建分片集群" class="headerlink" title="4.1. 搭建分片集群"></a>4.1. 搭建分片集群</h3><p>主从和哨兵可以解决高可用、高并发读的问题。但是依然有两个问题没有解决：</p>
<ul>
<li><p>海量数据存储问题</p>
</li>
<li><p>高并发写的问题</p>
</li>
</ul>
<p>使用分片集群可以解决上述问题，如图:</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023111653420.png" alt="image-20221023111653420"></p>
<p>分片集群特征：</p>
<ul>
<li><p>集群中有多个master，每个master保存不同数据</p>
</li>
<li><p>每个master都可以有多个slave节点</p>
</li>
<li><p>master之间通过ping监测彼此健康状态</p>
</li>
<li><p>客户端请求可以访问集群任意节点，最终都会被转发到正确节点</p>
</li>
</ul>
<h3 id="4-2-散列插槽"><a href="#4-2-散列插槽" class="headerlink" title="4.2. 散列插槽"></a>4.2. 散列插槽</h3><h4 id="4-2-1-插槽原理"><a href="#4-2-1-插槽原理" class="headerlink" title="4.2.1. 插槽原理"></a>4.2.1. 插槽原理</h4><p>Redis会把每一个master节点映射到0~16383共16384个插槽（hash slot）上，查看集群信息时就能看到：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023125648687.png" alt="image-20221023125648687"></p>
<p>数据key不是与节点绑定，而是与插槽绑定。redis会根据key的有效部分计算插槽值，分两种情况：</p>
<ul>
<li>key中包含”{}”，且“{}”中至少包含1个字符，“{}”中的部分是有效部分</li>
<li>key中不包含“{}”，整个key都是有效部分</li>
</ul>
<p>例如：key是num，那么就根据num计算，如果是{itcast}num，则根据itcast计算。计算方式是利用CRC16算法得到一个hash值，然后对16384取余，得到的结果就是slot值。</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023125927482.png" alt="image-20221023125927482"></p>
<p>如图，在7001这个节点执行set a 1时，对a做hash运算，对16384取余，得到的结果是15495，因此要存储到7003节点。</p>
<p>到了7003后，执行<code>get num</code>时，对num做hash运算，对16384取余，得到的结果是2765，因此需要切换到7001节点</p>
<h4 id="4-2-2-小结"><a href="#4-2-2-小结" class="headerlink" title="4.2.2. 小结"></a>4.2.2. 小结</h4><p>Redis如何判断某个key应该在哪个实例？</p>
<ul>
<li>将16384个插槽分配到不同的实例</li>
<li>根据key的有效部分计算哈希值，对16384取余</li>
<li>余数作为插槽，寻找插槽所在实例即可</li>
</ul>
<p>如何将同一类数据固定的保存在同一个Redis实例？</p>
<ul>
<li>这一类数据使用相同的有效部分，例如key都以{typeId}为前缀</li>
</ul>
<h3 id="4-3-集群伸缩"><a href="#4-3-集群伸缩" class="headerlink" title="4.3. 集群伸缩"></a>4.3. 集群伸缩</h3><p>redis-cli –cluster提供了很多操作集群的命令，可以通过下面方式查看：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023131102927.png" alt="image-20221023131102927"></p>
<p>比如，添加节点的命令：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023131123162.png" alt="image-20221023131123162"></p>
<h4 id="4-3-1-需求分析"><a href="#4-3-1-需求分析" class="headerlink" title="4.3.1. 需求分析"></a>4.3.1. 需求分析</h4><p>需求：向集群中添加一个新的master节点，并向其中存储 num &#x3D; 10</p>
<ul>
<li>启动一个新的redis实例，端口为7004</li>
<li>添加7004到之前的集群，并作为一个master节点</li>
<li>给7004节点分配插槽，使得num这个key可以存储到7004实例</li>
</ul>
<p>这里需要两个新的功能：</p>
<ul>
<li>添加一个节点到集群中</li>
<li>将部分插槽分配到新插槽</li>
</ul>
<h4 id="4-3-2-创建新的redis实例"><a href="#4-3-2-创建新的redis实例" class="headerlink" title="4.3.2. 创建新的redis实例"></a>4.3.2. 创建新的redis实例</h4><p>创建一个文件夹：</p>
<pre class=" language-sh"><code class="language-sh">mkdir 7004
</code></pre>
<p>拷贝配置文件：</p>
<pre class=" language-sh"><code class="language-sh">cp redis.conf 7004
</code></pre>
<p>修改配置文件：</p>
<pre class=" language-sh"><code class="language-sh">将6379端口改为7004
</code></pre>
<p>启动</p>
<pre class=" language-sh"><code class="language-sh">redis-server 7004/redis.conf
</code></pre>
<h4 id="4-3-3-添加新节点到redis"><a href="#4-3-3-添加新节点到redis" class="headerlink" title="4.3.3. 添加新节点到redis"></a>4.3.3. 添加新节点到redis</h4><p>添加节点的语法如下：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023132513427.png" alt="image-20221023132513427"></p>
<p>执行命令：</p>
<pre class=" language-sh"><code class="language-sh">redis-cli --cluster add-node  112.74.33.85:7004 112.74.33.85:7001
</code></pre>
<p>通过命令查看集群状态：</p>
<pre class=" language-sh"><code class="language-sh">redis-cli -p 7001 cluster nodes
</code></pre>
<p>如图，7004加入了集群，并且默认是一个master节点：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023133011493.png" alt="image-20221023133011493"></p>
<p>但是，可以看到7004节点的插槽数量为0，因此没有任何数据可以存储到7004上。</p>
<h4 id="4-3-4-转移插槽"><a href="#4-3-4-转移插槽" class="headerlink" title="4.3.4. 转移插槽"></a>4.3.4. 转移插槽</h4><p>我们要将num存储到7004节点，因此需要先看看num的插槽是多少：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023133207616.png" alt="image-20221023133207616"></p>
<p>如上图所示，num的插槽为2765.</p>
<p>我们可以将0~3000的插槽从7001转移到7004，命令格式如下：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023133235677.png" alt="image-20221023133235677"></p>
<p>具体命令如下：</p>
<p>建立连接：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023133422263.png" alt="image-20221023133422263"></p>
<p>得到下面的反馈：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023133455933.png" alt="image-20221023133455933"></p>
<p>询问要移动多少个插槽，我们计划是3000个：</p>
<p>新的问题来了：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023133525112.png" alt="image-20221023133525112"></p>
<p>那个node来接收这些插槽？？</p>
<p>显然是7004，那么7004节点的id是多少呢？</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023133558102.png" alt="image-20221023133558102"></p>
<p>复制这个id，然后拷贝到刚才的控制台后：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023133649772.png" alt="image-20221023133649772"></p>
<p>这里询问，你的插槽是从哪里移动过来的？</p>
<ul>
<li>all：代表全部，也就是三个节点各转移一部分</li>
<li>具体的id：目标节点的id</li>
<li>done：没有了</li>
</ul>
<p>这里我们要从7001获取，因此填写7001的id：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023133733483.png" alt="image-20221023133733483"></p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023133817321.png" alt="image-20221023133817321"></p>
<p>填完后，填写done，这样插槽转移就准备好了：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023133849292.png" alt="image-20221023133849292"></p>
<p>确认要转移吗？输入yes：</p>
<p>然后，通过命令查看结果：</p>
<pre class=" language-linux"><code class="language-linux">redis-cli -p 7001 cluster nodes
</code></pre>
<p>可以看到：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023134826264.png" alt="image-20221023134826264"></p>
<p>我们来测试一下，可见目的达成：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023134933361.png" alt="image-20221023134933361"></p>
<h3 id="4-4-故障转移"><a href="#4-4-故障转移" class="headerlink" title="4.4. 故障转移"></a>4.4. 故障转移</h3><h4 id="4-4-1-自动故障转移"><a href="#4-4-1-自动故障转移" class="headerlink" title="4.4.1 自动故障转移"></a>4.4.1 自动故障转移</h4><p>当集群中有一个master宕机会发生什么呢？</p>
<p>直接停止一个redis实例，例如7002：</p>
<pre class=" language-sh"><code class="language-sh">redis-cli -p 7002 shutdown
</code></pre>
<p>1）首先是该实例与其它实例失去连接</p>
<p>2）然后是疑似宕机：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023135725437.png" alt="image-20221023135725437"></p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023135748176.png" alt="image-20221023135748176"></p>
<p>3）最后是确定下线，自动提升slave为新的master：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023135827875.png" alt="image-20221023135827875"></p>
<p>4）当7002再次启动，就会变为一个slave节点了：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023135934314.png" alt="image-20221023135934314"></p>
<h4 id="4-4-2-手动故障转移"><a href="#4-4-2-手动故障转移" class="headerlink" title="4.4.2. 手动故障转移"></a>4.4.2. 手动故障转移</h4><p>利用cluster failover命令可以手动让集群中的某个master宕机，切换到执行cluster failover命令的这个slave节点，实现无感知的数据迁移。其流程如下：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023140059122.png" alt="image-20221023140059122"></p>
<p>这种failover命令可以指定三种模式：</p>
<ul>
<li>缺省：默认的流程，如图1~6歩</li>
<li>force：省略了对offset的一致性校验</li>
<li>takeover：直接执行第5歩，忽略数据一致性、忽略master状态和其它master的意见</li>
</ul>
<p><strong>案例需求</strong>：在7002这个slave节点执行手动故障转移，重新夺回master地位</p>
<p>步骤如下：</p>
<p>1）利用redis-cli连接7002这个节点</p>
<p>2）执行cluster failover命令</p>
<p>如图：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023144931933.png" alt="image-20221023144931933"></p>
<p>效果：</p>
<p><img src="https://github.com/cflxl/pictures/raw/master/markdown/redis/Redis-senior-distributedCache-.assets/image-20221023145126393.png" alt="image-20221023145126393"></p>
<h3 id="4-5-RedisTemplate访问分片集群"><a href="#4-5-RedisTemplate访问分片集群" class="headerlink" title="4.5. RedisTemplate访问分片集群"></a>4.5. RedisTemplate访问分片集群</h3><p>RedisTemplate底层同样基于lettuce实现了分片集群的支持，而使用的步骤与哨兵模式基本一致：</p>
<p>1）引入redis的starter依赖</p>
<p>2）配置分片集群地址</p>
<p>3）配置读写分离</p>
<p>与哨兵模式相比，其中只有分片集群的配置方式略有差异，如下：</p>
<pre class=" language-yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span>
  <span class="token key atrule">redis</span><span class="token punctuation">:</span>
    <span class="token key atrule">cluster</span><span class="token punctuation">:</span>
      <span class="token key atrule">nodes</span><span class="token punctuation">:</span>
        <span class="token punctuation">-</span> 112.74.33.85<span class="token punctuation">:</span><span class="token number">7001</span>
        <span class="token punctuation">-</span> 112.74.33.85<span class="token punctuation">:</span><span class="token number">7002</span>
        <span class="token punctuation">-</span> 112.74.33.85<span class="token punctuation">:</span><span class="token number">7003</span>
        <span class="token punctuation">-</span> 112.74.33.85<span class="token punctuation">:</span><span class="token number">8001</span>
        <span class="token punctuation">-</span> 112.74.33.85<span class="token punctuation">:</span><span class="token number">8002</span>
        <span class="token punctuation">-</span> 112.74.33.85<span class="token punctuation">:</span><span class="token number">8003</span>
</code></pre>

                
            </div>
            <hr/>

            



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/redis/">
                                    <span class="chip bg-color">redis</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    

    

</div>

                </div>
            </div>
            
                <div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="https://github.com/cflxl/pictures/raw/master/pictures/zhifubao.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="https://github.com/cflxl/pictures/raw/master/pictures/wxpay.jpg" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;Previous</div>
            <div class="card">
                <a href="/2022/10/06/redis-base/">
                    <div class="card-image">
                        
                        
                        <img src="https://github.com/cflxl/pictures/raw/master/pictures/20.jpg" class="responsive-img" alt="redis-base">
                        
                        <span class="card-title">redis-base</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2022-10-06
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            cflxl
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/redis/">
                        <span class="chip bg-color">redis</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                Next&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/2022/09/21/activemq/">
                    <div class="card-image">
                        
                        
                        <img src="https://github.com/cflxl/pictures/raw/master/pictures/15.jpg" class="responsive-img" alt="activemq">
                        
                        <span class="card-title">activemq</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2022-09-21
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-user fa-fw"></i>
                            cflxl
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/activemq/">
                        <span class="chip bg-color">activemq</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>



<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>



    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget card" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;TOC</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('2'),
            headingSelector: 'h1,h2, h3, h4,h5,h6'
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    

                <div class="container row center-align"
                    style="margin-bottom: 15px !important;">
                    <div class="col s12 m8 l8 copy-right">
                        Copyright&nbsp;&copy;
                        
                                <span id="year">
                                    2022
                                </span>
                                
                                    <a href="/about" target="_blank">
                                        cflxl
                                    </a>
                                    |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
                                    |&nbsp;Theme&nbsp;<a href="https://github.com/cflxl/cflxl.github.io"
                                        target="_blank">cflxl</a>
                                    <br>
                                    
                                        &nbsp;<i class="fas fa-chart-area"></i>&nbsp;Total Words
                                            :&nbsp;<span class="white-color">
                                                174.7k
                                            </span>
                                            
                                                
                                                    
                                                        
                                                            
                                                                
                                                                    <span id="busuanzi_container_site_pv">
                                                                        &nbsp;|&nbsp;<i class="far fa-eye"></i>&nbsp;Total visits:&nbsp;
                                                                            <span id="busuanzi_value_site_pv"
                                                                                class="white-color"></span>
                                                                    </span>
                                                                    
                                                                        
                                                                                <br>

                                                                                <!-- 运行天数提醒. -->
                                                                                
                                                                                    <span id="sitetime"> Loading
                                                                                        ...</span>
                                                                                    <script>
                                                                                        var calcSiteTime = function () {
                                                                                            var seconds = 1000;
                                                                                            var minutes = seconds * 60;
                                                                                            var hours = minutes * 60;
                                                                                            var days = hours * 24;
                                                                                            var years = days * 365;
                                                                                            var today = new Date();
                                                                                            var startYear = "2022";
                                                                                            var startMonth = "11";
                                                                                            var startDate = "15";
                                                                                            var startHour = "0";
                                                                                            var startMinute = "0";
                                                                                            var startSecond = "0";
                                                                                            var todayYear = today.getFullYear();
                                                                                            var todayMonth = today.getMonth() + 1;
                                                                                            var todayDate = today.getDate();
                                                                                            var todayHour = today.getHours();
                                                                                            var todayMinute = today.getMinutes();
                                                                                            var todaySecond = today.getSeconds();
                                                                                            var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                                                                                            var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                                                                                            var diff = t2 - t1;
                                                                                            var diffYears = Math.floor(diff / years);
                                                                                            var diffDays = Math.floor((diff / days) - diffYears * 365);

                                                                                            // 区分是否有年份.
                                                                                            var language = 'en';
                                                                                            if (startYear === String(todayYear)) {
                                                                                                document.getElementById("year").innerHTML = todayYear;
                                                                                                var daysTip = 'This site has been running for ' + diffDays + ' days';
                                                                                                if (language === 'zh-CN') {
                                                                                                    daysTip = '本站已运行 ' + diffDays + ' 天';
                                                                                                } else if (language === 'zh-HK') {
                                                                                                    daysTip = '本站已運行 ' + diffDays + ' 天';
                                                                                                }
                                                                                                document.getElementById("sitetime").innerHTML = daysTip;
                                                                                            } else {
                                                                                                document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                                                                                                var yearsAndDaysTip = 'This site has been running for ' + diffYears + ' years and '
                                                                                                    + diffDays + ' days';
                                                                                                if (language === 'zh-CN') {
                                                                                                    yearsAndDaysTip = '本站已运行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                                                                                                } else if (language === 'zh-HK') {
                                                                                                    yearsAndDaysTip = '本站已運行 ' + diffYears + ' 年 ' + diffDays + ' 天';
                                                                                                }
                                                                                                document.getElementById("sitetime").innerHTML = yearsAndDaysTip;
                                                                                            }
                                                                                        }

                                                                                        calcSiteTime();
                                                                                    </script>
                                                                                    
                                                                                        <br>
                                                                                        
                    </div>
                    <div class="col s12 m4 l4 social-link social-statis">
                        
    <a href="https://github.com/cflxl" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:2261497676@qq.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>







    <a href="tencent://AddContact/?fromId=50&fromSubId=1&subcmd=all&uin=2261497676" class="tooltipped" target="_blank" data-tooltip="QQ联系我: 2261497676" data-position="top" data-delay="50">
        <i class="fab fa-qq"></i>
    </a>







    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>


                    </div>
                </div>
</footer>

<div class="progress-bar"></div>

    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;Search</span>
            <input type="search" id="searchInput" name="s" placeholder="Please enter a search keyword"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script type="text/javascript">
$(function () {
    var searchFunc = function (path, search_id, content_id) {
        'use strict';
        $.ajax({
            url: path,
            dataType: "xml",
            success: function (xmlResponse) {
                // get the contents from search data
                var datas = $("entry", xmlResponse).map(function () {
                    return {
                        title: $("title", this).text(),
                        content: $("content", this).text(),
                        url: $("url", this).text()
                    };
                }).get();
                var $input = document.getElementById(search_id);
                var $resultContent = document.getElementById(content_id);
                $input.addEventListener('input', function () {
                    var str = '<ul class=\"search-result-list\">';
                    var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                    $resultContent.innerHTML = "";
                    if (this.value.trim().length <= 0) {
                        return;
                    }
                    // perform local searching
                    datas.forEach(function (data) {
                        var isMatch = true;
                        var data_title = data.title.trim().toLowerCase();
                        var data_content = data.content.trim().replace(/<[^>]+>/g, "").toLowerCase();
                        var data_url = data.url;
                        data_url = data_url.indexOf('/') === 0 ? data.url : '/' + data_url;
                        var index_title = -1;
                        var index_content = -1;
                        var first_occur = -1;
                        // only match artiles with not empty titles and contents
                        if (data_title !== '' && data_content !== '') {
                            keywords.forEach(function (keyword, i) {
                                index_title = data_title.indexOf(keyword);
                                index_content = data_content.indexOf(keyword);
                                if (index_title < 0 && index_content < 0) {
                                    isMatch = false;
                                } else {
                                    if (index_content < 0) {
                                        index_content = 0;
                                    }
                                    if (i === 0) {
                                        first_occur = index_content;
                                    }
                                }
                            });
                        }
                        // show search results
                        if (isMatch) {
                            str += "<li><a href='" + data_url + "' class='search-result-title'>" + data_title + "</a>";
                            var content = data.content.trim().replace(/<[^>]+>/g, "");
                            if (first_occur >= 0) {
                                // cut out 100 characters
                                var start = first_occur - 20;
                                var end = first_occur + 80;
                                if (start < 0) {
                                    start = 0;
                                }
                                if (start === 0) {
                                    end = 100;
                                }
                                if (end > content.length) {
                                    end = content.length;
                                }
                                var match_content = content.substr(start, end);
                                // highlight all keywords
                                keywords.forEach(function (keyword) {
                                    var regS = new RegExp(keyword, "gi");
                                    match_content = match_content.replace(regS, "<em class=\"search-keyword\">" + keyword + "</em>");
                                });

                                str += "<p class=\"search-result\">" + match_content + "...</p>"
                            }
                            str += "</li>";
                        }
                    });
                    str += "</ul>";
                    $resultContent.innerHTML = str;
                });
            }
        });
    };

    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 白天和黑夜主题 -->
<div class="stars-con">
    <div id="stars"></div>
    <div id="stars2"></div>
    <div id="stars3"></div>  
</div>

<script>
    function switchNightMode() {
        $('<div class="Cuteen_DarkSky"><div class="Cuteen_DarkPlanet"></div></div>').appendTo($('body')),
        setTimeout(function () {
            $('body').hasClass('DarkMode') 
            ? ($('body').removeClass('DarkMode'), localStorage.setItem('isDark', '0'), $('#sum-moon-icon').removeClass("fa-sun").addClass('fa-moon')) 
            : ($('body').addClass('DarkMode'), localStorage.setItem('isDark', '1'), $('#sum-moon-icon').addClass("fa-sun").removeClass('fa-moon')),
            
            setTimeout(function () {
            $('.Cuteen_DarkSky').fadeOut(1e3, function () {
                $(this).remove()
            })
            }, 2e3)
        })
    }
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    

    
        
        <script type="text/javascript">
            // 只在桌面版网页启用特效
            var windowWidth = $(window).width();
            if (windowWidth > 768) {
                document.write('<script type="text/javascript" src="/libs/others/sakura.js"><\/script>');
            }
        </script>
    

    <!-- 雪花特效 -->
    

    <!-- 鼠标星星特效 -->
    

    

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    <!--腾讯兔小巢-->
    
    

    

    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
